import * as logger from '../utils/logger';
import * as THREE from 'three';
import type { GeometryData } from 'crossworld-world';
import { Transform } from './transform';
import { BaseAvatar } from './base-avatar';
import { createTexturedVoxelMaterial, updateShaderLighting } from './textured-voxel-material';
import type { World } from '../physics/world';

export interface VoxelAvatarConfig {
  scale?: number;
  renderScaleDepth?: number; // Scale = 1 / 2^renderScaleDepth (default: 0.0 = no scaling)
  userNpub: string;
  materialId?: number; // Material ID to use for texturing (2-127 for textured materials)
  textures?: (THREE.Texture | undefined)[]; // Texture array for shader material
  enableTextures?: boolean; // Whether to enable textures (default: true)
  renderer?: THREE.WebGLRenderer; // Renderer for WebGL 2.0 texture array creation
  scene?: THREE.Scene; // Scene for lighting updates
}

/**
 * VoxelAvatar - A voxel-based avatar rendered from Rust-generated geometry
 *
 * This class takes geometry generated by Rust (voxel mesh) and creates a
 * Three.js object that can be moved and animated.
 */
export class VoxelAvatar extends BaseAvatar {
  private mesh: THREE.Mesh | null = null;
  private config: VoxelAvatarConfig;

  constructor(
    config: VoxelAvatarConfig,
    initialTransform?: Transform,
    scene?: THREE.Scene,
    physicsBridge?: World
  ) {
    super(initialTransform, scene, physicsBridge);
    this.config = config;
  }

  // ========== BaseAvatar hooks ==========

  protected getModel(): THREE.Object3D | null {
    return this.mesh;
  }

  protected getRotationOffset(): number {
    // MagicaVoxel models face opposite direction
    return Math.PI;
  }

  protected onStartMoving(): void {
    // No animations for voxel avatars
  }

  protected onStopMoving(): void {
    // No animations for voxel avatars
  }

  protected onJump(): void {
    // TODO: Add visual feedback for voxel avatar jump (scale bounce, particles, etc.)
    logger.log('avatar', 'VoxelAvatar jumped!');
  }

  // ========== VOX-specific implementation ==========

  /**
   * Apply voxel geometry from Rust WASM
   */
  applyGeometry(geometryData: GeometryData): void {
    // Remove old mesh if exists
    if (this.mesh) {
      this.group.remove(this.mesh);
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Create geometry from Rust data
    const geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array(geometryData.vertices);
    const indices = new Uint32Array(geometryData.indices);
    const normals = new Float32Array(geometryData.normals);
    const colors = new Float32Array(geometryData.colors);

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // Use pre-computed UVs from WASM (already generated in Rust)
    const uvs = geometryData.uvs ? new Float32Array(geometryData.uvs) : new Float32Array(vertices.length / 3 * 2);
    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

    // Use pre-computed material IDs from WASM, or override with config materialId for avatar texturing
    const configMaterialId = this.config.materialId ?? 0;
    let materialIds: Float32Array;
    if (configMaterialId !== 0) {
      // Override all material IDs with config value (for avatar-wide texture)
      materialIds = new Float32Array(vertices.length / 3).fill(configMaterialId);
    } else if (geometryData.materialIds) {
      // Use per-voxel material IDs from WASM
      materialIds = new Float32Array(geometryData.materialIds);
    } else {
      // Fallback to no textures
      materialIds = new Float32Array(vertices.length / 3).fill(0);
    }
    geometry.setAttribute('materialId', new THREE.BufferAttribute(materialIds, 1));

    logger.log('renderer', `[VoxelAvatar] Geometry from WASM:`, {
      vertexCount: vertices.length / 3,
      hasUvs: !!geometryData.uvs,
      hasMaterialIds: !!geometryData.materialIds,
      configMaterialId,
    });

    // Create material using the same shader system as the world cube
    const material = this.createShaderMaterial();

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;

    // Apply scale with renderScaleDepth FIRST
    const renderScaleDepth = this.config.renderScaleDepth ?? 2.0;
    const baseScale = this.config.scale || 1.0;
    const finalScale = baseScale / Math.pow(2, renderScaleDepth);
    this.mesh.scale.set(finalScale, finalScale, finalScale);

    // Calculate bounds AFTER scaling (like GLB avatar does)
    const bbox = new THREE.Box3().setFromObject(this.mesh);
    const size = new THREE.Vector3();
    bbox.getSize(size);

    // Position mesh according to AVATAR_PIVOT (0.5, 0, 0.5)
    // PIVOT (0.5, 0, 0.5) means: centered horizontally, feet on ground
    // Formula: position = -(min + size * pivot)
    this.mesh.position.x = -(bbox.min.x + size.x * BaseAvatar.PIVOT.x);
    this.mesh.position.z = -(bbox.min.z + size.z * BaseAvatar.PIVOT.z);
    this.mesh.position.y = -(bbox.min.y + size.y * BaseAvatar.PIVOT.y); // PIVOT.y = 0, so feet at y=0

    this.group.add(this.mesh);

    const textureInfo = configMaterialId >= 2 && configMaterialId <= 127 ? `materialId=${configMaterialId}` : 'vertex colors only';
    logger.log('renderer', `VoxelAvatar created for ${this.config.userNpub}:`, {
      vertices: vertices.length / 3,
      triangles: indices.length / 3,
      size: { x: size.x, y: size.y, z: size.z },
      texture: textureInfo
    });
  }

  /**
   * Create shader material using the same system as the world cube
   */
  private createShaderMaterial(): THREE.ShaderMaterial | THREE.RawShaderMaterial {
    const enableTextures = this.config.enableTextures ?? true;
    const textures = this.config.textures || [];
    const renderer = this.config.renderer;

    logger.log('renderer', `[VoxelAvatar] Creating shader material:`, {
      enableTextures,
      textureCount: textures.length,
      hasRenderer: !!renderer,
      materialId: this.config.materialId,
      hasScene: !!this.config.scene
    });

    // Use the shared createTexturedVoxelMaterial function
    const material = createTexturedVoxelMaterial(textures, enableTextures, renderer);

    // Update lighting if scene is provided
    if (this.config.scene) {
      updateShaderLighting(material, this.config.scene);
    }

    logger.log('renderer', `[VoxelAvatar] Material created, uniforms:`, {
      enableTextures: material.uniforms.enableTextures?.value,
      hasTextureArray: !!material.uniforms.textureArray?.value
    });

    return material;
  }

  /**
   * Clean up resources
   */
  protected onDispose(): void {
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Dispose profile icon
    if (this.profileIcon) {
      this.profileIcon.dispose();
    }
  }
}
