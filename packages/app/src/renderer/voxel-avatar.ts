import * as logger from '../utils/logger';
import * as THREE from 'three';
import type { GeometryData } from '@workspace/wasm';
import { Transform } from './transform';
import { BaseAvatar } from './base-avatar';

export interface VoxelAvatarConfig {
  scale?: number;
  renderScaleDepth?: number; // Scale = 1 / 2^renderScaleDepth (default: 0.0 = no scaling)
  userNpub: string;
}

/**
 * VoxelAvatar - A voxel-based avatar rendered from Rust-generated geometry
 *
 * This class takes geometry generated by Rust (voxel mesh) and creates a
 * Three.js object that can be moved and animated.
 */
export class VoxelAvatar extends BaseAvatar {
  private mesh: THREE.Mesh | null = null;
  private config: VoxelAvatarConfig;

  constructor(
    config: VoxelAvatarConfig,
    initialTransform?: Transform,
    scene?: THREE.Scene
  ) {
    super(initialTransform, scene);
    this.config = config;
  }

  // ========== BaseAvatar hooks ==========

  protected getModel(): THREE.Object3D | null {
    return this.mesh;
  }

  protected getRotationOffset(): number {
    // MagicaVoxel models face opposite direction
    return Math.PI;
  }

  protected onStartMoving(): void {
    // No animations for voxel avatars
  }

  protected onStopMoving(): void {
    // No animations for voxel avatars
  }

  // ========== VOX-specific implementation ==========

  /**
   * Apply voxel geometry from Rust WASM
   */
  applyGeometry(geometryData: GeometryData): void {
    // Remove old mesh if exists
    if (this.mesh) {
      this.group.remove(this.mesh);
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Create geometry from Rust data
    const geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array(geometryData.vertices);
    const indices = new Uint32Array(geometryData.indices);
    const normals = new Float32Array(geometryData.normals);
    const colors = new Float32Array(geometryData.colors);

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // Create material with vertex colors and flat shading for voxel aesthetic
    const material = new THREE.MeshPhongMaterial({
      vertexColors: true,
      flatShading: true, // Maintains blocky voxel look
      specular: 0x111111,
      shininess: 30,
      side: THREE.DoubleSide, // Render both sides to avoid holes
    });

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;

    // Apply scale with renderScaleDepth FIRST
    const baseScale = this.config.scale || 1.0;
    const renderScaleDepth = this.config.renderScaleDepth ?? 2.0;
    const finalScale = baseScale / Math.pow(2, renderScaleDepth);
    this.mesh.scale.set(finalScale, finalScale, finalScale);

    // Calculate bounds AFTER scaling (like GLB avatar does)
    const bbox = new THREE.Box3().setFromObject(this.mesh);
    const size = new THREE.Vector3();
    bbox.getSize(size);

    // Position mesh according to AVATAR_PIVOT (0.5, 0, 0.5)
    // PIVOT (0.5, 0, 0.5) means: centered horizontally, feet on ground
    // Formula: position = -(min + size * pivot)
    this.mesh.position.x = -(bbox.min.x + size.x * BaseAvatar.PIVOT.x);
    this.mesh.position.z = -(bbox.min.z + size.z * BaseAvatar.PIVOT.z);
    this.mesh.position.y = -(bbox.min.y + size.y * BaseAvatar.PIVOT.y); // PIVOT.y = 0, so feet at y=0

    this.group.add(this.mesh);

    logger.log('renderer', `VoxelAvatar created for ${this.config.userNpub}:`, {
      vertices: vertices.length / 3,
      triangles: indices.length / 3,
      size: { x: size.x, y: size.y, z: size.z }
    });
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Dispose profile icon
    if (this.profileIcon) {
      this.profileIcon.dispose();
    }
  }
}
