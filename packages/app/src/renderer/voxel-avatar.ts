import * as THREE from 'three';
import type { GeometryData } from '@workspace/wasm';
import { Transform } from './transform';

export interface VoxelAvatarConfig {
  scale?: number;
  userNpub: string;
}

/**
 * VoxelAvatar - A voxel-based avatar rendered from Rust-generated geometry
 *
 * This class takes geometry generated by Rust (voxel mesh) and creates a
 * Three.js object that can be moved and animated.
 */
export class VoxelAvatar {
  private group: THREE.Group;
  private mesh: THREE.Mesh | null = null;

  private transform: Transform;
  private targetTransform: Transform;
  private isMoving: boolean = false;
  private moveSpeed: number = 3.0; // units per second

  constructor(
    private config: VoxelAvatarConfig,
    initialTransform?: Transform
  ) {
    // Use provided transform or create default at (4, 0, 4)
    this.transform = initialTransform ? Transform.fromTransform(initialTransform) : new Transform(4, 0, 4);
    this.targetTransform = this.transform.clone();

    this.group = new THREE.Group();
    this.transform.applyToObject3D(this.group);
  }

  /**
   * Apply voxel geometry from Rust WASM
   */
  applyGeometry(geometryData: GeometryData): void {
    // Remove old mesh if exists
    if (this.mesh) {
      this.group.remove(this.mesh);
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Create geometry from Rust data
    const geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array(geometryData.vertices);
    const indices = new Uint32Array(geometryData.indices);
    const normals = new Float32Array(geometryData.normals);
    const colors = new Float32Array(geometryData.colors);

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // Create material with vertex colors and flat shading for voxel aesthetic
    const material = new THREE.MeshPhongMaterial({
      vertexColors: true,
      flatShading: true, // Maintains blocky voxel look
      specular: 0x111111,
      shininess: 30,
      side: THREE.DoubleSide, // Render both sides to avoid holes
    });

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;

    // Apply scale
    const scale = this.config.scale || 1.0;
    this.mesh.scale.set(scale, scale, scale);

    // Calculate geometry bounds before adding to group
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox!;

    // Center the mesh horizontally and place feet at y=0
    // The voxel model is generated with (0,0,0) at one corner
    // We need to offset so the model is centered at (0, 0, 0) in local space
    // with feet touching y=0
    this.mesh.position.x = -(bbox.min.x + bbox.max.x) / 2;
    this.mesh.position.z = -(bbox.min.z + bbox.max.z) / 2;
    this.mesh.position.y = -bbox.min.y; // Move up so bottom is at y=0

    this.group.add(this.mesh);

    const size = new THREE.Vector3();
    bbox.getSize(size);

    console.log(`VoxelAvatar created for ${this.config.userNpub}:`, {
      vertices: vertices.length / 3,
      triangles: indices.length / 3,
      size: { x: size.x, y: size.y, z: size.z }
    });
  }

  /**
   * Set target position for avatar to walk to (2D: x, z)
   */
  setTargetPosition(x: number, z: number): void {
    this.targetTransform.setXZ(x, z);
    this.isMoving = true;

    // Calculate direction and rotate to face it
    const dx = x - this.transform.getX();
    const dz = z - this.transform.getZ();
    const distance = Math.sqrt(dx * dx + dz * dz);

    if (distance > 0.01) {
      // Add π to flip 180° because MagicaVoxel models face opposite direction
      const angle = Math.atan2(dx, dz) + Math.PI;
      this.transform.setAngle(angle);
      this.targetTransform.setAngle(angle);
      this.group.quaternion.copy(this.transform.getRotation());
    }
  }

  /**
   * Update avatar position and movement
   */
  update(deltaTime_s: number): void {
    if (!this.isMoving) return;

    const distance = this.transform.distanceTo2D(this.targetTransform);

    if (distance < 0.1) {
      // Reached target
      this.transform.setXZ(this.targetTransform.getX(), this.targetTransform.getZ());
      this.group.position.set(this.transform.getX(), this.transform.getY(), this.transform.getZ());
      this.isMoving = false;
      return;
    }

    // Move towards target
    const moveDistance = this.moveSpeed * deltaTime_s;
    const dx = this.targetTransform.getX() - this.transform.getX();
    const dz = this.targetTransform.getZ() - this.transform.getZ();
    const direction = new THREE.Vector2(dx, dz).normalize();

    const actualMove = Math.min(moveDistance, distance);
    const newX = this.transform.getX() + direction.x * actualMove;
    const newZ = this.transform.getZ() + direction.y * actualMove;

    this.transform.setXZ(newX, newZ);
    this.group.position.set(this.transform.getX(), this.transform.getY(), this.transform.getZ());
  }

  /**
   * Get the Three.js group containing the avatar
   */
  getObject3D(): THREE.Group {
    return this.group;
  }

  /**
   * Get current transform (position + rotation)
   */
  getTransform(): Transform {
    return this.transform.clone();
  }

  /**
   * Get current position (legacy, returns Vector3)
   */
  getPosition(): THREE.Vector3 {
    return this.transform.getPosition();
  }

  /**
   * Check if avatar is currently moving
   */
  isCurrentlyMoving(): boolean {
    return this.isMoving;
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }
  }
}
