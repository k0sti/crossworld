import * as THREE from 'three';
import type { GeometryData } from '@workspace/wasm';

export interface VoxelAvatarConfig {
  scale?: number;
  userNpub: string;
}

/**
 * VoxelAvatar - A voxel-based avatar rendered from Rust-generated geometry
 *
 * This class takes geometry generated by Rust (voxel mesh) and creates a
 * Three.js object that can be moved and animated.
 */
export class VoxelAvatar {
  private group: THREE.Group;
  private mesh: THREE.Mesh | null = null;

  private position: THREE.Vector3;
  private targetPosition: THREE.Vector3;
  private isMoving: boolean = false;
  private moveSpeed: number = 3.0; // units per second

  constructor(
    private config: VoxelAvatarConfig,
    initialX: number = 4,
    initialZ: number = 4
  ) {
    this.position = new THREE.Vector3(initialX, 0, initialZ);
    this.targetPosition = this.position.clone();

    this.group = new THREE.Group();
    this.group.position.copy(this.position);
  }

  /**
   * Apply voxel geometry from Rust WASM
   */
  applyGeometry(geometryData: GeometryData): void {
    // Remove old mesh if exists
    if (this.mesh) {
      this.group.remove(this.mesh);
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Create geometry from Rust data
    const geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array(geometryData.vertices);
    const indices = new Uint32Array(geometryData.indices);
    const normals = new Float32Array(geometryData.normals);
    const colors = new Float32Array(geometryData.colors);

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // Create material with vertex colors and flat shading for voxel aesthetic
    const material = new THREE.MeshPhongMaterial({
      vertexColors: true,
      flatShading: true, // Maintains blocky voxel look
      specular: 0x111111,
      shininess: 30,
    });

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;

    // Apply scale
    const scale = this.config.scale || 1.0;
    this.mesh.scale.set(scale, scale, scale);

    // Center the mesh - voxel coordinates start at (0,0,0)
    // We want the avatar centered and feet on ground
    const box = new THREE.Box3().setFromObject(this.mesh);
    const size = box.getSize(new THREE.Vector3());

    // Center horizontally but keep feet on ground
    this.mesh.position.x = -size.x / 2;
    this.mesh.position.z = -size.z / 2;
    this.mesh.position.y = 0; // Feet at y=0

    this.group.add(this.mesh);

    console.log(`VoxelAvatar created for ${this.config.userNpub}:`, {
      vertices: vertices.length / 3,
      triangles: indices.length / 3,
      size
    });
  }

  /**
   * Set target position for avatar to walk to
   */
  setTargetPosition(x: number, z: number): void {
    this.targetPosition.set(x, 0, z);
    this.isMoving = true;

    // Rotate to face direction
    const direction = new THREE.Vector3()
      .subVectors(this.targetPosition, this.position)
      .normalize();

    if (direction.length() > 0.01) {
      const angle = Math.atan2(direction.x, direction.z);
      this.group.rotation.y = angle;
    }
  }

  /**
   * Update avatar position and movement
   */
  update(deltaTime_s: number): void {
    if (!this.isMoving) return;

    const distance = this.position.distanceTo(this.targetPosition);

    if (distance < 0.1) {
      // Reached target
      this.position.copy(this.targetPosition);
      this.group.position.copy(this.position);
      this.isMoving = false;
      return;
    }

    // Move towards target
    const moveDistance = this.moveSpeed * deltaTime_s;
    const direction = new THREE.Vector3()
      .subVectors(this.targetPosition, this.position)
      .normalize();

    this.position.addScaledVector(direction, Math.min(moveDistance, distance));
    this.group.position.copy(this.position);
  }

  /**
   * Get the Three.js group containing the avatar
   */
  getObject3D(): THREE.Group {
    return this.group;
  }

  /**
   * Get current position
   */
  getPosition(): THREE.Vector3 {
    return this.position.clone();
  }

  /**
   * Check if avatar is currently moving
   */
  isCurrentlyMoving(): boolean {
    return this.isMoving;
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }
  }
}
