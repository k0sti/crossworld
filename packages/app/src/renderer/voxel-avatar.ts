import * as THREE from 'three';
import type { GeometryData } from '@workspace/wasm';
import { Transform } from './transform';
import { BaseAvatar } from './base-avatar';

export interface VoxelAvatarConfig {
  scale?: number;
  userNpub: string;
}

/**
 * VoxelAvatar - A voxel-based avatar rendered from Rust-generated geometry
 *
 * This class takes geometry generated by Rust (voxel mesh) and creates a
 * Three.js object that can be moved and animated.
 */
export class VoxelAvatar extends BaseAvatar {
  private mesh: THREE.Mesh | null = null;
  private config: VoxelAvatarConfig;

  constructor(
    config: VoxelAvatarConfig,
    initialTransform?: Transform,
    scene?: THREE.Scene
  ) {
    super(initialTransform, scene);
    this.config = config;
  }

  // ========== BaseAvatar hooks ==========

  protected getModel(): THREE.Object3D | null {
    return this.mesh;
  }

  protected getRotationOffset(): number {
    // MagicaVoxel models face opposite direction
    return Math.PI;
  }

  protected onStartMoving(): void {
    // No animations for voxel avatars
  }

  protected onStopMoving(): void {
    // No animations for voxel avatars
  }

  // ========== VOX-specific implementation ==========

  /**
   * Apply voxel geometry from Rust WASM
   */
  applyGeometry(geometryData: GeometryData): void {
    // Remove old mesh if exists
    if (this.mesh) {
      this.group.remove(this.mesh);
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Create geometry from Rust data
    const geometry = new THREE.BufferGeometry();

    const vertices = new Float32Array(geometryData.vertices);
    const indices = new Uint32Array(geometryData.indices);
    const normals = new Float32Array(geometryData.normals);
    const colors = new Float32Array(geometryData.colors);

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));

    // Create material with vertex colors and flat shading for voxel aesthetic
    const material = new THREE.MeshPhongMaterial({
      vertexColors: true,
      flatShading: true, // Maintains blocky voxel look
      specular: 0x111111,
      shininess: 30,
      side: THREE.DoubleSide, // Render both sides to avoid holes
    });

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;

    // Apply scale
    const scale = this.config.scale || 1.0;
    this.mesh.scale.set(scale, scale, scale);

    // Calculate geometry bounds before adding to group
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox!;

    // Center the mesh horizontally and place feet at y=0
    // The voxel model is generated with (0,0,0) at one corner
    // We need to offset so the model is centered at (0, 0, 0) in local space
    // with feet touching y=0
    this.mesh.position.x = -(bbox.min.x + bbox.max.x) / 2;
    this.mesh.position.z = -(bbox.min.z + bbox.max.z) / 2;
    this.mesh.position.y = -bbox.min.y; // Move up so bottom is at y=0

    this.group.add(this.mesh);

    const size = new THREE.Vector3();
    bbox.getSize(size);

    console.log(`VoxelAvatar created for ${this.config.userNpub}:`, {
      vertices: vertices.length / 3,
      triangles: indices.length / 3,
      size: { x: size.x, y: size.y, z: size.z }
    });
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (Array.isArray(this.mesh.material)) {
        this.mesh.material.forEach(m => m.dispose());
      } else {
        this.mesh.material.dispose();
      }
    }

    // Dispose profile icon
    if (this.profileIcon) {
      this.profileIcon.dispose();
    }
  }
}
