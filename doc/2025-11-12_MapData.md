# Map Data Interface - Technical Specification

## Overview

This document describes the quadtree-based hierarchical map data interface for fetching and organizing elevation (height) and satellite imagery data for rectangular geographic regions. The interface supports adaptive level-of-detail (LOD) through hierarchical subdivision.

## Data Comparison: Finnish NLS vs Current Implementation

### Finnish National Land Survey (Maanmittauslaitos)

**Elevation Data:**
- **Source**: Airborne laser scanning (LiDAR)
- **Resolution**: 2m, 4m, 8m, 16m, 32m, 64m, 128m, 256m, 512m
- **Format**: GeoTIFF, ASCII Grid
- **Coverage**: Finland only (entire country)
- **Accuracy**: 0.3m (Class I) to 1m (Class II)
- **Coordinate System**: ETRS89 / TM35FIN (EPSG:3067)
- **Vertical Datum**: N2000 (EPSG:3900)
- **Access**: WCS API, OGC API Processes (requires free API key)
- **Update Frequency**: ~40,000 km² per year
- **License**: CC BY 4.0

**Satellite/Aerial Imagery:**
- **Source**: Aerial photography (not satellite)
- **Resolution**: 0.5m pixel size
- **Format**: GeoTIFF with TFW
- **Color Modes**: Grayscale (8-bit), RGB, false color (NIR-R-G), forest ortho
- **Coverage**: Finland only
- **Positional Accuracy**: 0.5-2m
- **Update Frequency**: Every 3 years (12 years in Northern Lapland)
- **Access**: WCS, WMTS, WMS, OGC API Processes
- **Historical Data**: Available from 1930s
- **License**: CC BY 4.0

### Current Implementation

**Elevation Data:**
- **Source**: SRTM (Shuttle Radar Topography Mission) via OpenTopography S3
- **Resolution**: 30m (GL1) or 90m (GL3)
- **Format**: GeoTIFF
- **Coverage**: Global (60°N to 56°S)
- **Access**: Direct S3 download (no authentication)
- **License**: Public domain

**Satellite Imagery:**
- **Primary Source**: Sentinel-2 L2A via AWS S3
- **Resolution**: 10m (RGB bands)
- **Format**: Cloud-Optimized GeoTIFF (COG)
- **Coverage**: Global
- **Update Frequency**: Every 5 days
- **Access**: STAC API + direct S3 (no authentication)
- **Cloud Filtering**: <5% cloud cover
- **License**: Free and open

**Alternative Sources:**
- Mapbox Satellite (1-10m, requires API key)
- Sentinel Hub (requires API key)
- OSM tile server fallback

### Key Differences

| Feature | Finnish NLS | Current Implementation |
|---------|-------------|----------------------|
| Best Resolution (Elevation) | **2m** | 30m |
| Best Resolution (Imagery) | **0.5m** | 10m |
| Coverage | Finland only | **Global** |
| Authentication | API key (free) | **None required** |
| Data Source | Aerial LiDAR/Photo | Satellite/Radar |
| Update Frequency | 3 years | **5 days** |
| Accuracy (Elevation) | **0.3-1m** | ~16m (SRTM) |
| Multi-resolution | **Yes (8 levels)** | No |

**Recommendation**: Use Finnish NLS for Finland-specific high-accuracy applications. Use current implementation for global coverage and real-time updates.

## Architecture

### Core Data Structure

```rust
/// Hierarchical quadtree node for map data
pub enum Quad<N, L> {
    /// Internal node containing aggregated data and four children
    Node {
        data: N,
        children: Box<[Quad<N, L>; 4]>,
    },
    /// Leaf node containing actual sampled data
    Leaf {
        data: L,
    },
}

/// Data stored at both nodes and leaves
#[derive(Clone, Debug)]
pub struct MapData {
    /// Elevation/height value in meters above sea level
    pub height: f32,

    /// RGB color packed as 0xRRGGBB (24-bit)
    /// R: bits 16-23, G: bits 8-15, B: bits 0-7
    pub color: u32,
}

/// Geographic bounds of a rectangular region
#[derive(Clone, Copy, Debug)]
pub struct Bounds {
    /// Northern boundary (latitude, degrees)
    pub north: f64,
    /// Southern boundary (latitude, degrees)
    pub south: f64,
    /// Eastern boundary (longitude, degrees)
    pub east: f64,
    /// Western boundary (longitude, degrees)
    pub west: f64,
}

impl Bounds {
    /// Calculate center point
    pub fn center(&self) -> (f64, f64) {
        let lat = (self.north + self.south) / 2.0;
        let lon = (self.east + self.west) / 2.0;
        (lat, lon)
    }

    /// Calculate dimensions in degrees
    pub fn dimensions(&self) -> (f64, f64) {
        let width = self.east - self.west;
        let height = self.north - self.south;
        (width, height)
    }
}
```

### Quadtree Subdivision

The quadtree subdivides space recursively:

```
+-------+-------+
|  NW   |  NE   |   Children indexed:
| [0]   | [1]   |   0: Northwest (NW)
+-------+-------+   1: Northeast (NE)
|  SW   |  SE   |   2: Southwest (SW)
| [2]   | [3]   |   3: Southeast (SE)
+-------+-------+
```

Each subdivision level increases resolution by 2^depth:
- Depth 0: 1x1 grid (single cell)
- Depth 1: 2x2 grid (4 cells)
- Depth 2: 4x4 grid (16 cells)
- Depth 3: 8x8 grid (64 cells)
- Depth N: (2^N)x(2^N) grid (4^N cells)

## Public API

### Primary Fetch Interface

```rust
use anyhow::Result;

/// Fetch map data for a rectangular region with hierarchical subdivision
///
/// # Arguments
/// * `bounds` - Geographic bounding box (lat/lon in degrees)
/// * `depth` - Subdivision depth (0-10 recommended)
/// * `sources` - Data sources configuration
///
/// # Returns
/// Quadtree with hierarchical map data
///
/// # Resolution
/// - Grid resolution: (2^depth) x (2^depth)
/// - Actual ground resolution depends on data source and region size
///
/// # Example
/// ```rust
/// let bounds = Bounds {
///     north: 60.5,
///     south: 60.0,
///     east: 25.5,
///     west: 25.0,
/// };
/// let depth = 8; // 256x256 grid
/// let sources = DataSources::default();
///
/// let quadtree = fetch_map_quadtree(bounds, depth, sources).await?;
/// ```
pub async fn fetch_map_quadtree(
    bounds: Bounds,
    depth: u32,
    sources: DataSources,
) -> Result<Quad<MapData, MapData>>;

/// Configuration for data sources
#[derive(Clone, Debug)]
pub struct DataSources {
    /// Elevation data source
    pub elevation: ElevationSource,
    /// Satellite/imagery data source
    pub imagery: ImagerySource,
}

#[derive(Clone, Debug)]
pub enum ElevationSource {
    /// SRTM via OpenTopography S3 (global, 30-90m, no auth)
    SRTM { resolution: SRTMResolution },

    /// Finnish NLS via WCS (Finland only, 2-512m, requires API key)
    FinnishNLS {
        api_key: String,
        resolution: u32, // 2, 4, 8, 16, 32, 64, 128, 256, or 512 meters
    },

    /// GeoCubes Finland (Finland only, 1-1000m, free)
    GeoCubes {
        resolution: u32,
    },
}

#[derive(Clone, Debug)]
pub enum SRTMResolution {
    /// 30m resolution (GL1)
    GL1,
    /// 90m resolution (GL3)
    GL3,
}

#[derive(Clone, Debug)]
pub enum ImagerySource {
    /// Sentinel-2 via AWS (global, 10m, no auth, may have clouds)
    Sentinel2 {
        max_cloud_cover: f32, // 0.0-100.0
    },

    /// Finnish NLS orthophotos (Finland only, 0.5m, requires API key)
    FinnishNLS {
        api_key: String,
        color_mode: ColorMode,
    },

    /// Mapbox satellite (global, 1-10m, requires token)
    Mapbox {
        token: String,
    },

    /// Sentinel Hub (global, custom processing, requires credentials)
    SentinelHub {
        client_id: String,
        client_secret: String,
    },
}

#[derive(Clone, Debug)]
pub enum ColorMode {
    /// Grayscale 8-bit
    Grayscale,
    /// RGB true color
    RGB,
    /// False color (NIR-R-G) for vegetation analysis
    FalseColor,
}

impl Default for DataSources {
    fn default() -> Self {
        Self {
            elevation: ElevationSource::SRTM {
                resolution: SRTMResolution::GL3,
            },
            imagery: ImagerySource::Sentinel2 {
                max_cloud_cover: 5.0,
            },
        }
    }
}
```

### Quadtree Operations

```rust
impl<N, L> Quad<N, L> {
    /// Get data at this node/leaf
    pub fn data(&self) -> &N where L: AsRef<N>;

    /// Get depth of this quadtree (0 for leaf)
    pub fn depth(&self) -> u32;

    /// Check if this is a leaf node
    pub fn is_leaf(&self) -> bool;

    /// Traverse quadtree with visitor pattern
    pub fn visit<F>(&self, f: &mut F)
    where F: FnMut(&Bounds, &N, u32);

    /// Sample quadtree at specific geographic coordinates
    pub fn sample(&self, lat: f64, lon: f64, bounds: &Bounds) -> Option<&L>;

    /// Get all leaf nodes at maximum depth
    pub fn leaves(&self) -> Vec<&L>;

    /// Convert to uniform grid at maximum depth
    pub fn to_grid(&self) -> Grid2D<L> where L: Clone;
}

/// 2D grid representation for uniform sampling
pub struct Grid2D<T> {
    pub width: usize,
    pub height: usize,
    pub data: Vec<T>,
}

impl<T> Grid2D<T> {
    pub fn get(&self, x: usize, y: usize) -> Option<&T> {
        if x < self.width && y < self.height {
            Some(&self.data[y * self.width + x])
        } else {
            None
        }
    }
}
```

### Data Aggregation for Nodes

Internal nodes aggregate data from their children:

```rust
impl MapData {
    /// Aggregate data from four child nodes
    /// - Height: average of children
    /// - Color: average of RGB components
    pub fn aggregate(children: &[MapData; 4]) -> Self {
        let height = children.iter().map(|c| c.height).sum::<f32>() / 4.0;

        // Average each RGB component separately
        let r = children.iter()
            .map(|c| ((c.color >> 16) & 0xFF) as u32)
            .sum::<u32>() / 4;
        let g = children.iter()
            .map(|c| ((c.color >> 8) & 0xFF) as u32)
            .sum::<u32>() / 4;
        let b = children.iter()
            .map(|c| (c.color & 0xFF) as u32)
            .sum::<u32>() / 4;

        let color = (r << 16) | (g << 8) | b;

        Self { height, color }
    }
}
```

## Implementation Strategy

### 1. Fetch Raw Data

```rust
async fn fetch_raw_elevation(
    bounds: Bounds,
    source: &ElevationSource,
) -> Result<RawElevationData>;

async fn fetch_raw_imagery(
    bounds: Bounds,
    source: &ImagerySource,
) -> Result<RawImageData>;
```

For Finnish NLS sources:

```rust
async fn fetch_finnish_elevation(
    bounds: Bounds,
    resolution: u32,
    api_key: &str,
) -> Result<RawElevationData> {
    // Convert bounds to EPSG:3067 (TM35FIN)
    let (emin, nmin) = wgs84_to_tm35fin(bounds.west, bounds.south)?;
    let (emax, nmax) = wgs84_to_tm35fin(bounds.east, bounds.north)?;

    // WCS GetCoverage request
    let url = format!(
        "https://avoin-karttakuva.maanmittauslaitos.fi/ortokuvat-ja-korkeusmallit/wcs/v2?\
         service=WCS&version=2.0.1&request=GetCoverage\
         &coverageId=korkeusmalli__{resolution}m\
         &subset=E({emin},{emax})&subset=N({nmin},{nmax})\
         &format=image/tiff&api-key={api_key}"
    );

    let response = reqwest::get(&url).await?;
    let geotiff_bytes = response.bytes().await?;

    parse_geotiff(geotiff_bytes)
}

async fn fetch_finnish_imagery(
    bounds: Bounds,
    color_mode: ColorMode,
    api_key: &str,
) -> Result<RawImageData> {
    let (emin, nmin) = wgs84_to_tm35fin(bounds.west, bounds.south)?;
    let (emax, nmax) = wgs84_to_tm35fin(bounds.east, bounds.north)?;

    let coverage_id = match color_mode {
        ColorMode::RGB => "ortokuva__rgb",
        ColorMode::FalseColor => "ortokuva__vaaravari",
        ColorMode::Grayscale => "ortokuva__mustavalko",
    };

    let url = format!(
        "https://avoin-karttakuva.maanmittauslaitos.fi/ortokuvat-ja-korkeusmallit/wcs/v2?\
         service=WCS&version=2.0.1&request=GetCoverage\
         &coverageId={coverage_id}\
         &subset=E({emin},{emax})&subset=N({nmin},{nmax})\
         &format=image/tiff&api-key={api_key}"
    );

    let response = reqwest::get(&url).await?;
    let geotiff_bytes = response.bytes().await?;

    parse_geotiff_image(geotiff_bytes)
}
```

### 2. Build Quadtree

```rust
fn build_quadtree(
    elevation: &RawElevationData,
    imagery: &RawImageData,
    bounds: Bounds,
    depth: u32,
) -> Quad<MapData, MapData> {
    if depth == 0 {
        // Leaf: sample data at center point
        let (lat, lon) = bounds.center();
        let height = elevation.sample(lat, lon);
        let color = imagery.sample_rgb(lat, lon);

        return Quad::Leaf {
            data: MapData { height, color },
        };
    }

    // Internal node: subdivide and recurse
    let (center_lat, center_lon) = bounds.center();

    let sub_bounds = [
        // Northwest [0]
        Bounds { north: bounds.north, south: center_lat, east: center_lon, west: bounds.west },
        // Northeast [1]
        Bounds { north: bounds.north, south: center_lat, east: bounds.east, west: center_lon },
        // Southwest [2]
        Bounds { north: center_lat, south: bounds.south, east: center_lon, west: bounds.west },
        // Southeast [3]
        Bounds { north: center_lat, south: bounds.south, east: bounds.east, west: center_lon },
    ];

    let children: [Quad<MapData, MapData>; 4] = sub_bounds
        .map(|b| build_quadtree(elevation, imagery, b, depth - 1));

    let data = MapData::aggregate(&children.map(|c| c.data().clone()));

    Quad::Node {
        data,
        children: Box::new(children),
    }
}
```

### 3. Coordinate Transformations

For Finnish NLS data, conversion between WGS84 and TM35FIN is required:

```rust
use proj::Proj;

fn wgs84_to_tm35fin(lon: f64, lat: f64) -> Result<(f64, f64)> {
    let proj = Proj::new_known_crs("EPSG:4326", "EPSG:3067", None)?;
    Ok(proj.convert((lon, lat))?)
}

fn tm35fin_to_wgs84(e: f64, n: f64) -> Result<(f64, f64)> {
    let proj = Proj::new_known_crs("EPSG:3067", "EPSG:4326", None)?;
    Ok(proj.convert((e, n))?)
}
```

## Usage Examples

### Example 1: Global Region with Sentinel-2

```rust
use map::*;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Madeira Island
    let bounds = Bounds {
        north: 32.88,
        south: 32.60,
        east: -16.65,
        west: -17.30,
    };

    let sources = DataSources::default(); // SRTM + Sentinel-2
    let depth = 8; // 256x256 grid

    let quadtree = fetch_map_quadtree(bounds, depth, sources).await?;

    println!("Quadtree depth: {}", quadtree.depth());
    println!("Leaf count: {}", quadtree.leaves().len());

    // Sample at specific location
    if let Some(data) = quadtree.sample(32.75, -16.95, &bounds) {
        println!("Height: {}m", data.height);
        println!("Color: #{:06X}", data.color);
    }

    Ok(())
}
```

### Example 2: Finland with High-Resolution NLS Data

```rust
use map::*;
use std::env;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let api_key = env::var("NLS_API_KEY")?;

    // Helsinki region
    let bounds = Bounds {
        north: 60.2,
        south: 60.1,
        east: 25.0,
        west: 24.9,
    };

    let sources = DataSources {
        elevation: ElevationSource::FinnishNLS {
            api_key: api_key.clone(),
            resolution: 2, // 2m resolution
        },
        imagery: ImagerySource::FinnishNLS {
            api_key,
            color_mode: ColorMode::RGB,
        },
    };

    let depth = 10; // 1024x1024 grid for high detail

    let quadtree = fetch_map_quadtree(bounds, depth, sources).await?;

    // Convert to uniform grid for rendering
    let grid = quadtree.to_grid();
    println!("Grid size: {}x{}", grid.width, grid.height);

    Ok(())
}
```

### Example 3: Mixed Sources (SRTM + NLS Imagery)

```rust
// Use global elevation but high-res Finnish imagery
let sources = DataSources {
    elevation: ElevationSource::SRTM {
        resolution: SRTMResolution::GL1, // 30m
    },
    imagery: ImagerySource::FinnishNLS {
        api_key: api_key.clone(),
        color_mode: ColorMode::RGB, // 0.5m
    },
};
```

## Performance Considerations

### Memory Usage

For depth `d`, the quadtree contains:
- **Leaf nodes**: 4^d
- **Total nodes**: (4^(d+1) - 1) / 3
- **Memory per node**: ~8 bytes (f32 + u32)

| Depth | Grid Size | Leaf Count | Total Nodes | Memory (approx) |
|-------|-----------|------------|-------------|----------------|
| 4 | 16x16 | 256 | 341 | 2.7 KB |
| 6 | 64x64 | 4,096 | 5,461 | 43 KB |
| 8 | 256x256 | 65,536 | 87,381 | 699 KB |
| 10 | 1024x1024 | 1,048,576 | 1,398,101 | 11 MB |
| 12 | 4096x4096 | 16,777,216 | 22,369,621 | 179 MB |

### Optimization Strategies

1. **Lazy Loading**: Build quadtree incrementally, fetching data only when needed
2. **Caching**: Cache raw data tiles to avoid redundant downloads
3. **Streaming**: Stream large datasets instead of loading entirely into memory
4. **LOD Selection**: Render only nodes visible at current zoom level
5. **Compression**: Use compressed formats (COG) for large imagery files

## Dependencies

```toml
[dependencies]
reqwest = { version = "0.11", features = ["blocking", "json"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
image = "0.24"
geo = "0.27"
proj = "0.27" # For coordinate transformations
geotiff = "0.4" # For parsing GeoTIFF files
```

## Error Handling

```rust
#[derive(Debug, thiserror::Error)]
pub enum MapDataError {
    #[error("Invalid bounds: {0}")]
    InvalidBounds(String),

    #[error("Depth {0} exceeds maximum {1}")]
    DepthExceeded(u32, u32),

    #[error("Data source unavailable: {0}")]
    SourceUnavailable(String),

    #[error("API authentication failed: {0}")]
    AuthFailed(String),

    #[error("Coordinate transformation failed: {0}")]
    TransformFailed(String),

    #[error("No data available for region")]
    NoData,
}
```

## Future Enhancements

1. **Adaptive Subdivision**: Vary depth based on terrain complexity
2. **Multi-Resolution**: Support different depths for elevation vs imagery
3. **Normal Maps**: Generate surface normals from elevation data
4. **Slope/Aspect**: Calculate terrain derivatives
5. **Temporal Data**: Support time series for change detection
6. **Compression**: Implement quadtree compression for flat regions
7. **GPU Upload**: Direct path to GPU texture/buffer formats
8. **Tile Cache**: Persistent cache for frequently accessed regions

## References

- [Finnish NLS Open Data](https://www.maanmittauslaitos.fi/en/maps-and-spatial-data)
- [Finnish NLS WCS API](https://www.maanmittauslaitos.fi/ortokuvien-ja-korkeusmallien-kyselypalvelu/tekninen-kuvaus)
- [OpenTopography SRTM](https://opentopography.s3.sdsc.edu)
- [Sentinel-2 on AWS](https://registry.opendata.aws/sentinel-2-l2a-cogs/)
- [STAC API Specification](https://github.com/radiantearth/stac-api-spec)
- [GeoCubes Finland](https://vm0160.kaj.pouta.csc.fi/geocubes/)
- [OGC Web Coverage Service (WCS) 2.0](https://www.ogc.org/standards/wcs)
